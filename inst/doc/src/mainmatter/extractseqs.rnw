\documentclass{article}
\input{../config/commontex}

\title{Importing zlib-compressed sequences}

\author{Lobry, J.R.}

\begin{document}
\SweaveInput{../config/commonrnw.rnw}
\maketitle
\tableofcontents
% BEGIN - DO NOT REMOVE THIS LINE
\label{extractseqs}
\section{Introduction}

There are two functions to get the sequences from an ACNUC server. 
The first one, \texttt{getSequence()}, uses regular socket connections, the
second one, \texttt{extractseqs()}, uses zlib compressed sockets,
which is faster but the function is experimental and has not
been extensively tested. This last function is not implemented for
Windows platforms. \texttt{exseq()} is an alias for \texttt{extractseqs()}.

The timings thereafter were from an home-ADSL connection, and are only indicative.
For this chapter we set up the bank to \texttt{emblTP} which is a frozen
subset of the EMBL database to allow for the reproducibility of results.

<<emblTP,fig=F>>=
(tcb <- system.time(choosebank("emblTP")))
@ 

It was then about \Sexpr{ifelse(exists("tcb"), round(as.numeric(tcb[3])), "???")} 
seconds to select the relevant database.

\section{Extacting 78,573 complete human nuclear CDS}

We suppose that the sequences we are interested in 
are all the complete coding sequences from \textit{Homo sapiens} that
are encoded in the nucleus (we don't want sequences from human mitochondrion). 

<<extractseq1, fig=F, eval=T>>=
(tqu <- system.time(query("hsCDS", 
  "sp=Homo sapiens AND t=cds AND o=nuclear AND NOT k=partial", virtual = TRUE)))
(nseq <- hsCDS$nelem)
(tex <- system.time(mycds <- extractseqs("hsCDS")))
@
 
We have used a virtual query to speed up things:
it was about \Sexpr{ifelse(exists("tqu"), round(as.numeric(tqu[3])), "???")} seconds 
to create on the server a list of \Sexpr{ifelse(exists("nseq"), nseq, "???")}
sequences. We have downloaded the sequences in zlib compressed mode:
it was about \Sexpr{ifelse(exists("tex"), round(as.numeric(tex[3])), "???")} seconds
to dowload the sequences in the object \texttt{mycds}, which looks like :

<<mycdslook,fig=F,eval=T>>=
cat(head(mycds), sep = "\n")
cat(tail(mycds), sep = "\n")
@

We save now the sequences in a local FASTA file for future use:

<<writefastat,fig=F,eval=T>>=
(twl <- system.time(writeLines(mycds, "mycds.fasta")))
@

It was then about \Sexpr{ifelse(exists("twl"), round(as.numeric(twl[3])), "???")} seconds
to dump the sequences on a local file. We read the sequences as strings
without setting attributes to save time:

<<readfastas,fig=F,eval=T>>=
(trf <- system.time(mycdss <- read.fasta("mycds.fasta", as.string = TRUE, set.attributes = FALSE)))
@

It was then about \Sexpr{ifelse(exists("trf"), round(as.numeric(trf[3])), "???")} seconds
to read the sequences as strings. We save them in XDR format:

<<saveRData,fig=F,eval=T>>=
(tsrd <- system.time(save(mycdss, file = "mycdss.RData")))
@

It was then about \Sexpr{ifelse(exists("tsrd"), round(as.numeric(tsrd[3])), "???")} seconds
to save the sequences in XDR format. How long is it to load the sequences
from XDR format?

<<loadRDatat,fig=F,eval=T>>=
(tlrd <-  system.time(load("mycdss.RData")))
@

It was then about \Sexpr{ifelse(exists("tlrd"), round(as.numeric(tlrd[3])), "???")} seconds
to load the sequences from an XDR formated file. 

\section{Extacting 78,573 complete human nuclear Proteins}

Now, we also want the corresponding proteins. We download the translated 
CDS from the server:

<<extractseq2,fig=F,eval=T>>=
(texp <- system.time(myprot <- extractseqs("hsCDS", operation = "translate")))
@

It was then about \Sexpr{ifelse(exists("texp"), round(as.numeric(texp[3])), "???")} seconds
to get the protein sequences from the server. The object \texttt{myprot} looks
like:

<<myprotlook,fig=F,eval=T>>=
cat(head(myprot), sep = "\n")
cat(tail(myprot), sep = "\n")
@

We save the protein sequences in a local FASTA file for future use:

<<writefastat2,fig=F,eval=T>>=
(twl2 <- system.time(writeLines(myprot, "myprot.fasta")))
@

It was then about \Sexpr{ifelse(exists("twl2"), round(as.numeric(twl2[3])), "???")} seconds
to dump the protein sequences on a local file. We read the sequences as strings
without setting attributes to save time:

<<readfastas2,fig=F,eval=T>>=
(trf2 <- system.time(myprots <- read.fasta("myprot.fasta", as.string = TRUE, set.attributes = FALSE)))
@

It was then about \Sexpr{ifelse(exists("trf2"), round(as.numeric(trf2[3])), "???")} seconds
to read the protein sequences as strings. We save them in XDR format:

<<saveRData2,fig=F,eval=T>>=
(tsrd2 <- system.time(save(myprots, file = "myprots.RData")))
@

It was then about \Sexpr{ifelse(exists("tsrd2"), round(as.numeric(tsrd2[3])), "???")} seconds
to save the protein sequences in XDR format. How long is it to load the 
protein sequences from XDR format?

<<loadRDatat2,fig=F,eval=T>>=
(tlrd2 <-  system.time(load("myprots.RData")))
@

It was then about \Sexpr{ifelse(exists("tlrd2"), round(as.numeric(tlrd2[3])), "???")} seconds
to load the protein sequences from an XDR formated file.

\section{Sanity check}

As a quick sanity check, we plot the distribution of protein size:

\setkeys{Gin}{width=\textwidth}

<<protsizeinhuman,fig=T,width=10,height=4>>=
x <- log10(nchar(myprots) - 1)
dstx <- density(x)
plot(dstx, main = paste("Protein size distribution in the human genome\nn = ", 
length(myprots), "proteins"),
xlab = "Number of amino-acids in log 10 scale", las = 1)
polycurve <- function(x, y, base.y = min(y), ...) 
  polygon(x = c(min(x), x, max(x)), y = c(base.y, y, base.y), ...)
polycurve(dstx$x, dstx$y, col = "yellow")
@ 

<<closebankextractseqs,fig=F>>=
closebank()
@ 

\SweaveInput{../config/sessionInfo.rnw}

% END - DO NOT REMOVE THIS LINE

%%%%%%%%%%%%  BIBLIOGRAPHY %%%%%%%%%%%%%%%%%
\clearpage
\addcontentsline{toc}{section}{References}
\bibliographystyle{plain}
\bibliography{../config/book}
\end{document}
