\documentclass{article}
\input{../config/commontex}

\title{How to deal with sequences}
\author{Charif, D. \and Lobry, J.R.}

\usepackage{/Library/Frameworks/R.framework/Resources/share/texmf/Sweave}
\begin{document}
%
% To change the R input/output style:
%
\definecolor{Soutput}{rgb}{0,0,0.56}
\definecolor{Sinput}{rgb}{0.56,0,0}
\DefineVerbatimEnvironment{Sinput}{Verbatim}
{formatcom={\color{Sinput}},fontsize=\footnotesize, baselinestretch=0.75}
\DefineVerbatimEnvironment{Soutput}{Verbatim}
{formatcom={\color{Soutput}},fontsize=\footnotesize, baselinestretch=0.75}
%
% This removes the extra spacing after code and output chunks in Sweave,
% but keeps the spacing around the whole block.
%
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}
%
% Rlogo
%
\newcommand{\Rlogo}{\protect\includegraphics[height=1.8ex,keepaspectratio]{../figs/Rlogo.pdf}}
%
% Shortcut for seqinR:
%
\newcommand{\seqinr}{\texttt{seqin\bf{R}}}
\newcommand{\Seqinr}{\texttt{Seqin\bf{R}}}
\fvset{fontsize= \scriptsize}
%
% R output options and libraries to be loaded.
%
%
%  Sweave Options
%
% Put all figures in the fig folder and start the name with current file name.
% Do not produce EPS files
%


\maketitle
% BEGIN - DO NOT REMOVE THIS LINE

\section{Sequence classes}


There are currently 5 classes of sequences, depending on the way they were obtained:

\begin{itemize}
  \item {\bfseries SeqFastadna} is the class for nucleic acid sequences that were imported from a fasta file.
  \item {\bfseries SeqFastaAA} is the class for amino-acid acid sequences that were imported from a fasta file.
  \item {\bfseries seqAcnucWeb} is the class for the sequences coming from an ACNUC database server.
  \item {\bfseries SeqFrag} is the class for the sequences that are fragments of other sequences.
  \item {\bfseries qaw} is the class for the result of a call to the \texttt{query()} function.
\end{itemize}

\section{Generic methods for sequences}

All sequence classes are sharing a common interface, so that there are very few method names we 
have to remember. 
In addition, all classes have their specific \texttt{as.ClassName} method that return an 
instance of the class, and \texttt{is.ClassName} method to check whether an object belongs 
or not to the class. Available methods are summarized in table \ref{tabmeth}.

\begin{table} 
\begin{tabular}{lll}
\hline \hline
{\bfseries Methods} & {\bfseries Result} & {\bfseries Type of result} \\
\hline
{\bfseries getFrag} & a sequence fragment & a sequence fragment \\
{\bfseries getSequence} & the sequence & vector of characters \\
{\bfseries getName} & the name of a sequence & string \\
{\bfseries getLength} & the length of a sequence & numeric vector \\
{\bfseries getTrans} & translation into amino-acids & vector of characters \\
{\bfseries getAnnot} & sequence annotations & vector of string \\
{\bfseries getLocation} & position of a Sequence on its parent sequence & list of numeric vector \\
\hline \hline
\end{tabular}
\caption{Available methods for sequence classes.}
\label{tabmeth}
\end{table}

\subsection{From classes to methods}

To obtain the list of methods available for a given class, try this at your \Rlogo{}~prompt:

\begin{Schunk}
\begin{Sinput}
 methods(class = "SeqFastadna")
\end{Sinput}
\begin{Soutput}
[1] getAnnot.SeqFastadna    getFrag.SeqFastadna     getLength.SeqFastadna  
[4] getName.SeqFastadna     getSequence.SeqFastadna getTrans.SeqFastadna   
[7] summary.SeqFastadna    
\end{Soutput}
\begin{Sinput}
 methods(class = "SeqFastaAA")
\end{Sinput}
\begin{Soutput}
[1] getAnnot.SeqFastaAA    getFrag.SeqFastaAA     getLength.SeqFastaAA  
[4] getName.SeqFastaAA     getSequence.SeqFastaAA summary.SeqFastaAA    
\end{Soutput}
\begin{Sinput}
 methods(class = "SeqAcnucWeb")
\end{Sinput}
\begin{Soutput}
 [1] getAnnot.SeqAcnucWeb    getFrag.SeqAcnucWeb     getKeyword.SeqAcnucWeb 
 [4] getLength.SeqAcnucWeb   getLocation.SeqAcnucWeb getName.SeqAcnucWeb    
 [7] getSequence.SeqAcnucWeb getTrans.SeqAcnucWeb    plot.SeqAcnucWeb       
[10] print.SeqAcnucWeb      
\end{Soutput}
\begin{Sinput}
 methods(class = "SeqFrag")
\end{Sinput}
\begin{Soutput}
[1] getFrag.SeqFrag     getLength.SeqFrag   getName.SeqFrag    
[4] getSequence.SeqFrag getTrans.SeqFrag   
\end{Soutput}
\begin{Sinput}
 methods(class = "qaw")
\end{Sinput}
\begin{Soutput}
[1] getAnnot.qaw    getFrag.qaw     getKeyword.qaw  getLength.qaw  
[5] getLocation.qaw getName.qaw     getSequence.qaw getTrans.qaw   
[9] print.qaw      
\end{Soutput}
\end{Schunk}

\subsection{From methods to classes}

To obtain the list of classes for which a given method exists, try this at your \Rlogo{}~prompt:

\begin{Schunk}
\begin{Sinput}
 methods(getFrag)
\end{Sinput}
\begin{Soutput}
[1] getFrag.SeqAcnucWeb getFrag.SeqFastaAA  getFrag.SeqFastadna
[4] getFrag.SeqFrag     getFrag.character   getFrag.default    
[7] getFrag.list        getFrag.logical     getFrag.qaw        
\end{Soutput}
\begin{Sinput}
 methods(getSequence)
\end{Sinput}
\begin{Soutput}
[1] getSequence.SeqAcnucWeb getSequence.SeqFastaAA  getSequence.SeqFastadna
[4] getSequence.SeqFrag     getSequence.character   getSequence.default    
[7] getSequence.list        getSequence.logical     getSequence.qaw        
\end{Soutput}
\begin{Sinput}
 methods(getName)
\end{Sinput}
\begin{Soutput}
[1] getName.SeqAcnucWeb getName.SeqFastaAA  getName.SeqFastadna
[4] getName.SeqFrag     getName.default     getName.list       
[7] getName.logical     getName.qaw        
\end{Soutput}
\begin{Sinput}
 methods(getLength)
\end{Sinput}
\begin{Soutput}
[1] getLength.SeqAcnucWeb getLength.SeqFastaAA  getLength.SeqFastadna
[4] getLength.SeqFrag     getLength.character   getLength.default    
[7] getLength.list        getLength.logical     getLength.qaw        
\end{Soutput}
\begin{Sinput}
 methods(getTrans)
\end{Sinput}
\begin{Soutput}
[1] getTrans.SeqAcnucWeb getTrans.SeqFastadna getTrans.SeqFrag    
[4] getTrans.character   getTrans.default     getTrans.list       
[7] getTrans.logical     getTrans.qaw        
\end{Soutput}
\begin{Sinput}
 methods(getAnnot)
\end{Sinput}
\begin{Soutput}
[1] getAnnot.SeqAcnucWeb getAnnot.SeqFastaAA  getAnnot.SeqFastadna
[4] getAnnot.default     getAnnot.list        getAnnot.logical    
[7] getAnnot.qaw        
\end{Soutput}
\begin{Sinput}
 methods(getLocation)
\end{Sinput}
\begin{Soutput}
[1] getLocation.SeqAcnucWeb getLocation.default     getLocation.list       
[4] getLocation.logical     getLocation.qaw        
\end{Soutput}
\end{Schunk}


\section{Internal representation of sequences}

The default mode of sequence storage is done with vectors of characters instead of strings\footnote{
This default behaviour can be neutralized by setting the \texttt{as.string} argument to TRUE.
}.
This is very convenient for the user because all \Rlogo{}~ tools to manipulate vectors are immediatly available. 
The price to pay is that this storage mode is extremly expensive in terms of memory.
They are two utilities called \texttt{s2c()} and \texttt{c2s()} that allows to convert strings into 
vector of characters, and \textit{vice versa}, respectively.

\subsection{Sequences as vectors of characters}

In the vectorial representation mode, all the very convenient \Rlogo{}~ tools for indexing vectors
are at hand.
\begin{enumerate}
\item Vectors can be indexed by a vector of \emph{positive} integers saying which
elements are to be selected. As we have already seen, the first 50 elements of a sequence
are easily extracted thanks to the binary operator \texttt{from:to}, as in:

\begin{Schunk}
\begin{Sinput}
 dnafile <- system.file("sequences/malM.fasta", package = "seqinr")
 myseq <- read.fasta(file = dnafile)[[1]]
 1:50
\end{Sinput}
\begin{Soutput}
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
[25] 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
[49] 49 50
\end{Soutput}
\begin{Sinput}
 myseq[1:50]
\end{Sinput}
\begin{Soutput}
 [1] "a" "t" "g" "a" "a" "a" "a" "t" "g" "a" "a" "t" "a" "a" "a" "a" "g" "t"
[19] "c" "t" "c" "a" "t" "c" "g" "t" "c" "c" "t" "c" "t" "g" "t" "t" "t" "a"
[37] "t" "c" "a" "g" "c" "a" "g" "g" "g" "t" "t" "a" "c" "t"
\end{Soutput}
\end{Schunk}

The \texttt{seq()} function allows to build more complexe integer vectors. For instance
in coding sequences it is very common to focus on third codon positions where
selection is weak. Let's extract bases from third codon positions:

\begin{Schunk}
\begin{Sinput}
 tcp <- seq(from = 3, to = length(myseq), by = 3)
 tcp[1:10]
\end{Sinput}
\begin{Soutput}
 [1]  3  6  9 12 15 18 21 24 27 30
\end{Soutput}
\begin{Sinput}
 myseqtcp <- myseq[tcp]
 myseqtcp[1:10]
\end{Sinput}
\begin{Soutput}
 [1] "g" "a" "g" "t" "a" "t" "c" "c" "c" "c"
\end{Soutput}
\end{Schunk}
 
 \item Vectors can also be indexed by a vector of \emph{negative} integers saying which
elements have to be removed. For instance, if we want to keep first and second codon positions,
the easiest way is to remove third codon positions:

\begin{Schunk}
\begin{Sinput}
 -tcp[1:10]
\end{Sinput}
\begin{Soutput}
 [1]  -3  -6  -9 -12 -15 -18 -21 -24 -27 -30
\end{Soutput}
\begin{Sinput}
 myseqfscp <- myseq[-tcp]
 myseqfscp[1:10]
\end{Sinput}
\begin{Soutput}
 [1] "a" "t" "a" "a" "a" "t" "a" "a" "a" "a"
\end{Soutput}
\end{Schunk}

\item Vectors are also indexable by a vector of \emph{logicals} whose \texttt{TRUE}
values say which elements to keep. Here is a different way to extract all third coding positions
from our sequence. First, we define a vector of three logicals with only the last one true:

\begin{Schunk}
\begin{Sinput}
 ind <- c(F, F, T)
 ind
\end{Sinput}
\begin{Soutput}
[1] FALSE FALSE  TRUE
\end{Soutput}
\end{Schunk}

This vector seems too short for our purpose because our sequence is much more longer
with its 921 bases. But under \Rlogo{}~ vectors are automatically \emph{recycled}
when they are not long enough:

\begin{Schunk}
\begin{Sinput}
 (1:30)[ind]
\end{Sinput}
\begin{Soutput}
 [1]  3  6  9 12 15 18 21 24 27 30
\end{Soutput}
\begin{Sinput}
 myseqtcp2 <- myseq[ind]
\end{Sinput}
\end{Schunk}

The result should be the same as previously:

\begin{Schunk}
\begin{Sinput}
 identical(myseqtcp, myseqtcp2)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

This recycling rule is extremely convenient in practice but may have surprising
effects if you assume (incorrectly) that there is a stringent dimension control for \Rlogo{}~ vectors
as in linear algebra.

\end{enumerate}

Another advantage of working with vector of characters is that most \Rlogo{}~ functions
are vectorized so that many things can be done without explicit looping. Let's
give some very simple examples:

\begin{Schunk}
\begin{Sinput}
 (tota <- sum(myseq == "a"))
\end{Sinput}
\begin{Soutput}
[1] 238
\end{Soutput}
\end{Schunk}

The total number of \texttt{a} in our sequence is 238. Let's compare
graphically the different base counts in our sequence. The following code was used to
produce figure \ref{vecto2}:

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/dealseq-vecto2}
\caption{Visual representation of the base counts in a nucleic acid sequence.}
\label{vecto2}
\end{minipage}
}
\end{figure}

\begin{Schunk}
\begin{Sinput}
 basecount <- table(myseq)
 myseqname <- getName(myseq)
 dotchart(basecount, xlim = c(0, max(basecount)), pch = 19, 
     main = paste("Base count in", myseqname))
\end{Sinput}
\end{Schunk}

The following code was used to display (\textit{cf} figure \ref{vecto3}) 
the dinucleotide counts in the sequence:

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/dealseq-vecto3}
\caption{Visual representation of dinucleotide counts in a nucleic acid sequence.}
\label{vecto3}
\end{minipage}
}
\end{figure}

\begin{Schunk}
\begin{Sinput}
 dinuclcount <- count(myseq, 2)
 dotchart(dinuclcount[order(dinuclcount)], xlim = c(0, max(dinuclcount)), 
     pch = 19, main = paste("Dinucleotide count in", myseqname))
\end{Sinput}
\end{Schunk}

The following code was used to display (\textit{cf} figure \ref{vecto4}) 
the codon usage in the sequence:

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/dealseq-vecto4}
\caption{Visual representation of codon usage in a coding sequence with
  the function \texttt{dotchart.uco()}. Codons are grouped by amino-acid
  for a given genetic code. Black dots are the sums by synonymous codons,
  that is the amino-acid count.}
\label{vecto4}
\end{minipage}
}
\end{figure}

\begin{Schunk}
\begin{Sinput}
 codonusage <- uco(myseq)
 dotchart.uco(codonusage, main = paste("Codon usage in", myseqname))
\end{Sinput}
\end{Schunk}

\clearpage

\subsection{Sequences as strings}

If you are interested in (fuzzy) pattern matching, then it is advisable to work with
sequence as strings to take advantage of \emph{regular expression} implemented
in \Rlogo{}. The function \texttt{words.pos()} returns the positions of all occurrences
of a given regular expression. Let's suppose we want to know where are the trinucleotides
"cgt" in a sequence, that is the fragment CpGpT in the direct strand:

\begin{Schunk}
\begin{Sinput}
 mystring <- c2s(myseq)
 (cgt <- words.pos("cgt", mystring))
\end{Sinput}
\begin{Soutput}
 [1]  24  90 216 245 252 315 330 405 432 452 552 592 648 836 883
\end{Soutput}
\begin{Sinput}
 substring(mystring, cgt, cgt + 2)
\end{Sinput}
\begin{Soutput}
 [1] "cgt" "cgt" "cgt" "cgt" "cgt" "cgt" "cgt" "cgt" "cgt" "cgt" "cgt" "cgt"
[13] "cgt" "cgt" "cgt"
\end{Soutput}
\end{Schunk}

We can also look for the fragment CpGpTpY to illustrate fuzzy matching because
Y (IUPAC code for pyrimidine) stands C or T:

\begin{Schunk}
\begin{Sinput}
 (cgty <- words.pos("cgt[ct]", mystring))
\end{Sinput}
\begin{Soutput}
 [1]  24 216 252 315 432 452 552 592 836 883
\end{Soutput}
\begin{Sinput}
 substring(mystring, cgty, cgty + 3)
\end{Sinput}
\begin{Soutput}
 [1] "cgtc" "cgtt" "cgtc" "cgtt" "cgtt" "cgtt" "cgtc" "cgtc" "cgtt" "cgtt"
\end{Soutput}
\end{Schunk}

To look for all CpC dinucleotides separated by 3 or 4 bases:
\begin{Schunk}
\begin{Sinput}
 (cc34cc <- words.pos("cc.{3,4}cc", mystring, perl = TRUE))
\end{Sinput}
\begin{Soutput}
 [1]  72 119 176 177 539 577 578 638 677 682 730 731 736 881 882
\end{Soutput}
\begin{Sinput}
 substring(mystring, cc34cc, cc34cc + 7)
\end{Sinput}
\begin{Soutput}
 [1] "ccttgccg" "ccattcca" "cccagacc" "ccagacca" "cctatgcc" "cccgatcc"
 [7] "ccgatccg" "ccagctcc" "ccgctcca" "ccagctcc" "cccgctcc" "ccgctccg"
[13] "ccggcacc" "cccgttcc" "ccgttcca"
\end{Soutput}
\end{Schunk}

Virtually any pattern is easily encoded with a regular expression. This is
especially useful at the protein level because many functions can be attributed 
to short linear motifs.


\section*{Session Informations}

This part was compiled under the following \Rlogo{}~environment:

\begin{itemize}
  \item R version 2.8.0 (2008-10-20), \verb|i386-apple-darwin8.8.2|
  \item Locale: \verb|C|
  \item Base packages: base, datasets, grDevices, graphics, methods,
    stats, utils
  \item Other packages: MASS~7.2-44, ade4~1.4-9, ape~2.2-2,
    nlme~3.1-89, quadprog~1.4-11, seqinr~2.0-0, tseries~0.10-16,
    xtable~1.5-4, zoo~1.5-4
  \item Loaded via a namespace (and not attached): grid~2.8.0,
    lattice~0.17-15, tools~2.8.0
\end{itemize}
There were two compilation steps:

\begin{itemize}
  \item \Rlogo{} compilation time was: Sun Oct 26 18:11:55 2008
  \item \LaTeX{} compilation time was: \today
\end{itemize}

% END - DO NOT REMOVE THIS LINE

%%%%%%%%%%%%  BIBLIOG\Rlogo{}~APHY %%%%%%%%%%%%%%%%%
\clearpage
\addcontentsline{toc}{section}{\Rlogo{}~eferences}
\bibliographystyle{plain}
\bibliography{../config/book}
\end{document}
