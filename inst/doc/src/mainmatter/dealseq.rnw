\documentclass{article}
\input{../config/commontex}

\title{How to deal with sequences}
\author{Charif, D. \and Lobry, J.R.}

\begin{document}
\SweaveInput{../config/commonrnw.rnw}
\maketitle
% BEGIN - DO NOT REMOVE THIS LINE

\section{Sequence classes}


There are currently 5 classes of sequences, depending on the way they were obtained:

\begin{itemize}
  \item {\bfseries SeqFastadna} is the class for nucleic acid sequences that were imported from a fasta file.
  \item {\bfseries SeqFastaAA} is the class for amino-acid acid sequences that were imported from a fasta file.
  \item {\bfseries seqAcnucWeb} is the class for the sequences coming from an ACNUC database server.
  \item {\bfseries SeqFrag} is the class for the sequences that are fragments of other sequences.
  \item {\bfseries qaw} is the class for the result of a call to the \texttt{query()} function.
\end{itemize}

\section{Generic methods for sequences}

All sequence classes are sharing a common interface, so that there are very few method names we 
have to remember. 
In addition, all classes have their specific \texttt{as.ClassName} method that return an 
instance of the class, and \texttt{is.ClassName} method to check whether an object belongs 
or not to the class. Available methods are summarized in table \ref{tabmeth}.

\begin{table} 
\begin{tabular}{lll}
\hline \hline
{\bfseries Methods} & {\bfseries Result} & {\bfseries Type of result} \\
\hline
{\bfseries getFrag} & a sequence fragment & a sequence fragment \\
{\bfseries getSequence} & the sequence & vector of characters \\
{\bfseries getName} & the name of a sequence & string \\
{\bfseries getLength} & the length of a sequence & numeric vector \\
{\bfseries getTrans} & translation into amino-acids & vector of characters \\
{\bfseries getAnnot} & sequence annotations & vector of string \\
{\bfseries getLocation} & position of a Sequence on its parent sequence & list of numeric vector \\
\hline \hline
\end{tabular}
\caption{Available methods for sequence classes.}
\label{tabmeth}
\end{table}

\subsection{From classes to methods}

To obtain the list of methods available for a given class, try this at your \Rlogo{}~prompt:

<<methodslisting,fig=F>>=
methods(class = "SeqFastadna")
methods(class = "SeqFastaAA")
methods(class = "SeqAcnucWeb")
methods(class = "SeqFrag")
methods(class = "qaw")
@ 

\subsection{From methods to classes}

To obtain the list of classes for which a given method exists, try this at your \Rlogo{}~prompt:

<<classeslisting,fig=F>>=
methods(getFrag)
methods(getSequence)
methods(getName)
methods(getLength)
methods(getTrans)
methods(getAnnot)
methods(getLocation)
@ 


\section{Internal representation of sequences}

The default mode of sequence storage is done with vectors of characters instead of strings\footnote{
This default behaviour can be neutralized by setting the \texttt{as.string} argument to TRUE.
}.
This is very convenient for the user because all \Rlogo{}~ tools to manipulate vectors are immediatly available. 
The price to pay is that this storage mode is extremly expensive in terms of memory.
They are two utilities called \texttt{s2c()} and \texttt{c2s()} that allows to convert strings into 
vector of characters, and \textit{vice versa}, respectively.

\subsection{Sequences as vectors of characters}

In the vectorial representation mode, all the very convenient \Rlogo{}~ tools for indexing vectors
are at hand.
\begin{enumerate}
\item Vectors can be indexed by a vector of \emph{positive} integers saying which
elements are to be selected. As we have already seen, the first 50 elements of a sequence
are easily extracted thanks to the binary operator \texttt{from:to}, as in:

<<fromto,eval=T>>=
dnafile <- system.file("sequences/malM.fasta", package = "seqinr")
myseq <- read.fasta(file = dnafile)[[1]]
1:50
myseq[1:50]
@

The \texttt{seq()} function allows to build more complexe integer vectors. For instance
in coding sequences it is very common to focus on third codon positions where
selection is weak. Let's extract bases from third codon positions:

<<seqtcp,eval=T>>=
tcp <- seq(from = 3, to = length(myseq), by = 3)
tcp[1:10]
myseqtcp <- myseq[tcp]
myseqtcp[1:10]
@
 
 \item Vectors can also be indexed by a vector of \emph{negative} integers saying which
elements have to be removed. For instance, if we want to keep first and second codon positions,
the easiest way is to remove third codon positions:

<<seqfscp, eval=T>>=
-tcp[1:10]
myseqfscp <- myseq[-tcp]
myseqfscp[1:10]
@

\item Vectors are also indexable by a vector of \emph{logicals} whose \texttt{TRUE}
values say which elements to keep. Here is a different way to extract all third coding positions
from our sequence. First, we define a vector of three logicals with only the last one true:

<<ind, eval=T>>=
ind <- c(F, F, T)
ind
@

This vector seems too short for our purpose because our sequence is much more longer
with its \Sexpr{ifelse(exists("myseq"), length(myseq), "???")} bases. But under \Rlogo{}~ vectors are automatically \emph{recycled}
when they are not long enough:

<<myseqtcp2, eval=T>>=
(1:30)[ind]
myseqtcp2 <- myseq[ind]
@

The result should be the same as previously:

<<identical, eval=T>>=
 identical(myseqtcp, myseqtcp2)
@

This recycling rule is extremely convenient in practice but may have surprising
effects if you assume (incorrectly) that there is a stringent dimension control for \Rlogo{}~ vectors
as in linear algebra.

\end{enumerate}

Another advantage of working with vector of characters is that most \Rlogo{}~ functions
are vectorized so that many things can be done without explicit looping. Let's
give some very simple examples:

<<vectorized1, eval=T>>=
(tota <- sum(myseq == "a"))
@

The total number of \texttt{a} in our sequence is \Sexpr{ifelse(exists("tota"), tota, "???")}. Let's compare
graphically the different base counts in our sequence. The following code was used to
produce figure \ref{vecto2}:

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/dealseq-vecto2}
\caption{Visual representation of the base counts in a nucleic acid sequence.}
\label{vecto2}
\end{minipage}
}
\end{figure}

<<vecto2, height = 3, fig=TRUE, include=F, eval=T>>=
basecount <- table(myseq)
myseqname <- getName(myseq)
dotchart(basecount, xlim = c(0, max(basecount)), pch = 19,
  main = paste("Base count in",  myseqname))
@

The following code was used to display (\textit{cf} figure \ref{vecto3}) 
the dinucleotide counts in the sequence:

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/dealseq-vecto3}
\caption{Visual representation of dinucleotide counts in a nucleic acid sequence.}
\label{vecto3}
\end{minipage}
}
\end{figure}

<<vecto3, fig=TRUE, include = F, eval=T>>=
dinuclcount <- count(myseq, 2)
dotchart(dinuclcount[order(dinuclcount)], xlim = c(0, max(dinuclcount)), pch = 19,
  main = paste("Dinucleotide count in",  myseqname))
@

The following code was used to display (\textit{cf} figure \ref{vecto4}) 
the codon usage in the sequence:

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/dealseq-vecto4}
\caption{Visual representation of codon usage in a coding sequence with
  the function \texttt{dotchart.uco()}. Codons are grouped by amino-acid
  for a given genetic code. Black dots are the sums by synonymous codons,
  that is the amino-acid count.}
\label{vecto4}
\end{minipage}
}
\end{figure}

<<vecto4, height = 10, fig=TRUE, include = F, eval=T>>=
codonusage <- uco(myseq)
dotchart.uco(codonusage, main = paste("Codon usage in",  myseqname))
@

\clearpage

\subsection{Sequences as strings}

If you are interested in (fuzzy) pattern matching, then it is advisable to work with
sequence as strings to take advantage of \emph{regular expression} implemented
in \Rlogo{}. The function \texttt{words.pos()} returns the positions of all occurrences
of a given regular expression. Let's suppose we want to know where are the trinucleotides
"cgt" in a sequence, that is the fragment CpGpT in the direct strand:

<<cgt, eval=T>>=
mystring <- c2s(myseq)
(cgt <- words.pos("cgt", mystring))
substring(mystring, cgt, cgt+2)
@

We can also look for the fragment CpGpTpY to illustrate fuzzy matching because
Y (IUPAC code for pyrimidine) stands C or T:

<<fuzzy, eval=T>>=
(cgty <- words.pos("cgt[ct]", mystring))
substring(mystring, cgty, cgty+3)
@

To look for all CpC dinucleotides separated by 3 or 4 bases:
<<fuzzy2, eval=T>>=
(cc34cc <- words.pos("cc.{3,4}cc", mystring, perl = TRUE))
substring(mystring, cc34cc, cc34cc+7)
@

Virtually any pattern is easily encoded with a regular expression. This is
especially useful at the protein level because many functions can be attributed 
to short linear motifs.

\SweaveInput{../config/sessionInfo.rnw}

% END - DO NOT REMOVE THIS LINE

%%%%%%%%%%%%  BIBLIOG\Rlogo{}~APHY %%%%%%%%%%%%%%%%%
\clearpage
\addcontentsline{toc}{section}{\Rlogo{}~eferences}
\bibliographystyle{plain}
\bibliography{../config/book}
\end{document}
