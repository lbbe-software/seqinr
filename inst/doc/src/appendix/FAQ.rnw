\documentclass{article}
\input{../config/commontex}

\title{FAQ: Frequently Asked Questions}
\author{Lobry, J.R.}

\begin{document}
\SweaveInput{../config/commonrnw.rnw}
\maketitle
% BEGIN - DO NOT REMOVE THIS LINE

\section{How can I compute a score over a moving window?}

As an illustration, suppose that we want to reproduce a part
of figure 1 from \cite{LobryMBE96} whose screenshot is given
is given in figure \ref{gcskewmbe96}.

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/gcskewmbe96}
\caption{Screenshot of a part of figure 1 from \cite{LobryMBE96}.
  The GC-skew is computed in non-overlapping windows of 10 Kb
  along a 1.6 Mb fragment of the \textit{Escherichia coli}
  chromosome. The sequence is available with \texttt{data(m16j)}.}
\label{gcskewmbe96}
\end{minipage}
}
\end{figure}


The score here is the GC-skew computed in non-overlapping
windows of 10 Kb for a 1.6 Mb sequence.
We need a fragment of \textit{Escherchia coli} K12 chromosome from
67.4 min to 4.1 min on the genetic map\footnote{
The sequence is also directly available with \texttt{data(m16j)}.
}. Let's put this fragment into the string \texttt{myseq}:

<<getmyseq,fig=F,eval=T>>=
choosebank("greview")
myseq1 <-gfrag("U00096", start = 3217270, length = 10^7)
myseq2 <- gfrag("U00096", start = 1, length = 194133)
closebank()
myseq <- paste(myseq1, myseq2, sep = "")
nchar(myseq)
@ 

This is not exactly the same sequence that was used in \cite{LobryMBE96}
but very close to\footnote{
The sequence used in \cite{LobryMBE96} was a 1,616,174 bp fragment obtained
from the concatenation of nine overlapping sequences
(U18997, U00039, L10328, M87049, L19201, U00006, U14003, D10483, D26562
\cite{SofiaHJ1994, BurlandV1993, DanielsDL1992, PlunkettG1993, BlattnerFR1993, YuraT1992}).
Ambiguities have been resolved since then and its was a chimeric sequence
from K-12 strains MG1655 and W3110 \cite{HayashiK2006}, the sequence used here
is from strain MG1655 only \cite{BlattnerFR1997}. 
}. We define a function called \texttt{gcskew()} that computes our score 
for a given string \texttt{x}:

<<scoredef,fig=F>>=
gcskew <- function(x){
  if( !is.character(x) || length(x) > 1 ) stop("single string expected")
  tmp <- tolower(s2c(x))
  nC <- sum(tmp == "c")
  nG <- sum(tmp == "g")
  if( nC + nG == 0 ) return(NA)
  return(100*(nC - nG)/(nC + nG))
}
gcskew("GCCC")
gcskew("GCCCNNNNNN")
@

Note some defensive programming tricks used here:

\begin{itemize}
\item We check that the argument \texttt{x} is a single string.
\item We expand it as vector of single chars with \texttt{s2c()} only within the
      function to avoid big objects in the workspace.
\item We force to lower case letters with \texttt{tolower()} so that we can use 
      upper case letters too.
\item We avoid division by zero and return \texttt{NA} in this case.
\item We do not divide by the length of \texttt{x} but by the actual number
      of C and G so that ambiguous bases such as N do not introduce biases.
\end{itemize}


We move now along the sequence to compute the GC-skew:

<<movingwindow,fig=F>>=
step <- 10000
wsize <- 10000
starts <- seq(from = 1, to = nchar(myseq), by = step)
starts <- starts[-length(starts)] # remove last one
n <- length(starts)
result <- numeric(n)
for(i in seq_len(n)){
	result[i] <- gcskew(substr(myseq, starts[i], starts[i] + wsize - 1))
}
@ 

The following code\footnote{
This code is adapted from the code at \url{http://www.stat.auckland.ac.nz/~paul/RGraphics/chapter3.html} for
figure 3.25 in Paul Murrell's book \cite{MurrellP2005}. This book is a must read if you are interested
by \Rlogo{}'s \textit{force de frappe} in the graphic domain. 
} was used to produce figure \ref{gcplot}.

<<gcplot,fig=T,include=F,width=9.1,height=4.5>>=
xx <- starts/1000
yy <- result
n <- length(result)
hline <- 0

plot (yy ~ xx, type="n", axes=FALSE, ann=FALSE, ylim = c(-10, 10))
polygon(c(xx[1], xx, xx[n]), c(min(yy), yy, min(yy)), col = "black", border=NA)

usr <- par("usr")
rect(usr[1], usr[3], usr[2], hline, col="white", border=NA)

lines(xx, yy)

abline (h=hline)
box()
axis(1, at = seq(0,1600, by = 200))
axis(2, las = 1) 
title(xlab = "position (Kbp)", ylab = "(C-G)/(C+G) %", 
main = expression(paste("GC skew in ", italic(Escherichia~~coli))))
arrows(860, 5.5, 720, 0.5, length = 0.1, lwd = 2)
text(860, 5.5, "origin of replication", pos = 4)
@ 

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/FAQ-gcplot}
\caption{Re-creation of figure \ref{gcskewmbe96} from scratch.}
\label{gcplot}
\end{minipage}
}
\end{figure}

You can now play with the \texttt{wsize} and \texttt{step} parameters
to explore the signal (but note that with overlapping windows your
points are no more independent) or use all the smoothing tools
available under \Rlogo{}. Figure \ref{demolowess} shows for instance 
what can be obtained with the \texttt{lowess()} function with two
values for the smoothing parameter \texttt{f}. The corresponding code
is as follows:

<<demolowess,fig=T,include=F,width=9.1,height=4.5>>=
plot(xx,yy, col = "grey", type = "b", ylim = c(-10,10), las = 1, xaxt = "n",
main = expression(paste("GC skew in ", italic(Escherichia~~coli))),
xlab = "position (Kbp)", ylab = "(C-G)/(C+G) %")
axis(1, at = seq(0,1600, by = 200))

lines(smooth <- lowess(xx,yy, f = 0.05), lwd = 1)
polycurve <- function(x, y, base.y = min(y), ...) polygon(x = c(min(x), x, max(x)), y = c(base.y, y, base.y), ...)
up <- smooth$y > 0
polycurve(smooth$x[up], smooth$y[up], base.y = 0, col = rgb(0,0,1,0.5))

lines(lowess(xx,yy, f = 0.2), lwd = 2, col = "red")
legend("topright", inset = 0.01, legend = c("f = 0.05", "f = 0.20"), lwd = c(1,2), col = c("black", "red"))
abline(h=0)
arrows(860, 5.5, 720, 0.5, length = 0.1, lwd = 2)
text(860, 5.5, "origin of replication", pos = 4)
@ 

\begin{figure}
\centering\fbox{
\begin{minipage}{\textwidth}
\centering
\includegraphics[width=\textwidth]{../figs/FAQ-demolowess}
\caption{Playing with the smoothing parameter \texttt{f} of
  the \texttt{lowess()} function.}
\label{demolowess}
\end{minipage}
}
\end{figure}


\section{How can I extract just a fragment from my sequence?}

Use the generic function \texttt{getFrag()} :

<<getFrag,fig=F>>=
choosebank("emblTP")
query("mylist", "AC=A00001")
getFrag(mylist$req[[1]], begin = 10, end = 20)
closebank()
@ 

\section{How do I compute a score on my sequences?}

In the example below we want to compute the G+C content in third codon
positions for complete ribosomal CDS from \textit{Escherichia coli}:

<<gc3, fig=F,eval=T>>=
choosebank("emblTP")
query("ecribo","sp=escherichia coli ET t=cds ET k=ribosom@ ET NO k=partial")
myseqs <- sapply(ecribo$req, getSequence)
(gc3 <- sapply(myseqs, GC3))
@

At the amino-acid level, we may get an estimate of the isoelectric point of
the proteins this way:

<<computePI,fig=F,eval=T>>=
sapply( sapply(myseqs, getTrans), computePI)
@

Note that some pre-defined vectors to compute linear forms on sequences are
available in the \texttt{EXP} data.

As a matter of convenience, you may encapsulate the computation of your favorite score 
within a function this way:

<<encapsulate,fig=F,eval=T>>=
GC3m <- function(list, ind = 1:list$nelem) sapply(sapply(list$req[ind], getSequence), GC3)
GC3m(ecribo)
GC3m(ecribo, 1:10)
@

\section{Why do I have not exactly the same G+C content as in \texttt{codonW}?}

This question was raised (and solved) by Oliver Clay in an e-mail (23-AUG-2006).
The program \texttt{codonW} was written in C as part of John Peden's PhD thesis 
on Codon Usage \cite{codonW} and is available at \url{http://codonw.sourceforge.net/}.
The reason for the small differences in G+C content between the two programs is
that the default behavior in \texttt{codonW} is to remove the stop codon before
computations. Here is one way of removing the stop codon under \Rlogo{}:

<<gc3nos, fig=F,eval=T>>=
gc3nos <- sapply(myseqs, function(s) GC3(s[1:(length(s) - 3)]))
@

As compared with the previous result, the difference is small but visible:

<<stopcodonremovaleffect,fig=T,eval=T>>=
plot(x = gc3, y = gc3nos, las =1, main="Stop codon removal effect on G+C content
in third codon positions", xlab = "With stop codon", ylab ="Stop codons removed")
abline(c(0,1))
@

\texttt{CodonW} was released with a test file called \texttt{input.dat}, here are
the first 10 lines of the file copied from \texttt{CodonWSourceCode\_1\_4\_4}:

<<headinputdat,fig=F,eval=T>>=
inputdatfile <- system.file("sequences/input.dat", package = "seqinr")
cat(readLines(inputdatfile,n=10), sep = "\n")
@

This is a FASTA file that we import under \Rlogo{}~with:

<<importinputdat,fig=F,eval=T>>=
input <- read.fasta(file = inputdatfile)
names(input)
@

The file \texttt{input.out} contains the values obtained with \texttt{codonW}
for the GC content and GC3s content:

<<inputout,fig=F,eval=T>>=
inputoutfile <- system.file("sequences/input.out", package = "seqinr")
cat(readLines(inputoutfile, n=10), sep = "\n")
input.res <- read.table(inputoutfile, header = TRUE)
head(input.res)
@

Let's try to reproduce the results for the G+C content, we know that we have to
remove the last stop codon:

<<inputgc,fig=T,eval=T>>=
input.gc <- sapply(input, function(s) GC(s[1:(length(s)-3)]))
max(abs(input.gc - input.res$GC))
plot(x = input.gc, y = input.res$GC, las = 1,
xlab = "Results with GC()", ylab = "Results from codonW",
main = "Comparison of G+C content results")
abline(c(0,1))
@

The results are consistent if we consider that we have 3 significant digits
in the file \texttt{input.out}. Now, let's try to reproduce the results
for G+C in third codon positions:

<<inputgc3,fig=T,eval=T>>=
input.gc3 <- sapply(input, function(s) GC3(s[1:(length(s)-3)]))
max(abs(input.gc3 - input.res$GC3s))
plot(x = input.gc3, y = input.res$GC3s, las = 1,
xlab = "Results with GC3()", ylab = "Results from codonW",
main = "Comparison of G+C content in third codon positions results")
abline(c(0,1))
@

There is clearly a problem here. Looking into the documentation of
\texttt{codonW}, GC3s is the G+C content in third codon position
after removing non-synonymous and stop codons (those corresponding to Met, Trp, Stp).
Let's remove these codons:

<<inputgc3s,fig=T,eval=T>>=
codons <- words()
names(codons) <- sapply(codons, function(c) aaa(translate(s2c(c), numcode = 1)))
okcodons <- codons[! names(codons) %in% c("Met", "Trp", "Stp")]
gc3s <- function(s){
  tmp <- splitseq(s)
  tmp <- tmp[tmp %in% okcodons]
  tmp <- s2c(paste(tmp, collapse = ""))
  GC3(tmp)
}
input.gc3s <- sapply(input, gc3s)
max(abs(input.gc3s - input.res$GC3s))

plot(x = input.gc3s, y = input.res$GC3s, las = 1,
xlab = "Results with GC3()", ylab = "Results from codonW",
main = "Comparison of G+C content in third codon positions results\n(Met, Trp and Stp codons excluded)")
abline(c(0,1))
@

The results are now consistent. But thinking more about it there is still a problem
with the codons for Ile:

<<ilecodons,fig=F,eval=T>>=
codons[names(codons) == "Ile"]
@

There are three codons for Ile. If the distribution of the four bases was uniform and selectively
neutral in third codon position of synonymous codons, then we would expect to
get a G+C of 50\% in quartet and duet codons at third codons positions because they
all have the same number of W (A or T )and S (C or G) bases in third position. But for Ile 
we have two codons ending in W versus only one in S so that we would get a G+C
of $\frac{1}{3}$ instead of $\frac{1}{2}$. This point was clearly stated 
\cite{noboru88} by Sueoka in 1988:

\begin{quote}
\textbf{G + C Content of the Three Codons Positions.}
In the present analysis, observed G + C contents of the first, second, and third
codon positions ($P_{1}$, $P_{2}$, and $P_{3}$, respectively) are corrected
average G + C contents of the three codon positions that are calculated from
56 triplets out of 64. Because of the inequality of $\alpha$ and $\gamma$ at the
third codon position, the three stop codons (TAA, TAG, and TGA) and the three
codons for isoleucine (ATT, ATC, and ATA) were excluded in calculation of
$P_{3}$, and two single codons for methionine (ATG) and tryptophan (TGG)
were excluded in all three ($P_{1}$, $P_{2}$, and $P_{3}$)
\end{quote}

Let's compute $P_{3}$ and compare it with GC3s:

<<inputP3,fig=T,eval=T>>=
P3codons <- codons[! names(codons) %in% c("Met", "Trp", "Ile", "Stp")]

P3 <- function(s){
  tmp <- splitseq(s)
  tmp <- tmp[tmp %in% P3codons]
  tmp <- s2c(paste(tmp, collapse = ""))
  GC3(tmp)
}
input.P3 <- sapply(input, P3)
max(abs(input.P3 - input.res$GC3s))

plot(x = input.P3, y = input.res$GC3s, las = 1,
xlab = "Results with P3", ylab = "Results from codonW GC3s",
main = "Comparison of P3 and GC3s")
abline(c(0,1))
@

This is not exactly the same, the maximum observed difference here is about $3\%$.
In practice, $P_{3}$, GC3, and GC3s are only slightly different \cite{noboru99}.

\section{How do I get a sequence from its name?}

This question is adapted from an e-mail (22 Jun 2006) by Gang Xu.
I know that the UniProt (SwissProt) entry of my protein is \texttt{P08758},
if I know its name\footnote{
More exactly, this is the accession number. Sequence names are not stable over time,
it's always better to use the accession numbers. 
}, how can I get the sequence?

<<uniprot,fig=F,eval=T>>=
choosebank("swissprot") 
query("myprot","AC=P08758")
getSequence(myprot$req[[1]])       
@

\SweaveInput{../config/sessionInfo.rnw}

% END - DO NOT REMOVE THIS LINE

%%%%%%%%%%%%  BIBLIOGRAPHY %%%%%%%%%%%%%%%%%
\clearpage
\addcontentsline{toc}{section}{References}
\bibliographystyle{plain}
\bibliography{../config/book}
\end{document}
